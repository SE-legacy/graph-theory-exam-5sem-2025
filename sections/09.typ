== Алгоритм Дейкстры: поиск кратчайших путей от одной вершины.

- Задача: Дан взвешенный граф $G = (V, E)$. Веса ребере $w(u, v) >= 0$
  (неотрицательные) Найти кратчайшие пути от заданной исходной вершины s до
  всех остальных вершин графа.

== Необходимые определения
- *Вес пути*: Сумма весов всех ребер, входящих в этот путь.
- *Кратчайший путь $(p(s, v))$*: путь минимально возможным весом из $s$ в $v$.
- *Массив dist[]*, где dist[v] --- длина кратчайшего пути из $s$ в $v$.
- *Массив pred[]*, позволяющий восстанавливать сам путь.
- *Операция "Релаксации"*: Основная операция
  - Имеем: текущая оценка расстояния до $v$ --- dist[v]
  - Рассматриваем ребро (u, v).
  - Если $#[dist] [u] + w(u, v) < #[dist] [v]$, то мы нашли более короткий путь через $u$
  - Обновляем: $#[dist] [v] = #[dist] [u] + w(u, v)$ и $#[prev] [v] = u$.

== Описание алгоритма
+ Для всех вершин установить, что они еще не посещены, $#[dist] [v] = $.
  Для вершины, с которой начинается поиск, $#[dist] [s] = 0$.
+ Пока есть не посещённые вершины:
  - Выбрать вершину u с минимальным значением $#[dist] [u]$ среди непосещённых.
  - Пометить u как посещённую. (Её $#[dist] [u]$ теперь окончателен)
  - Для каждого соседа $v$ вершины $u$ релаксировать ребро $(u, v)$.

== Псевдокод Алгоритма
// FIX: код

= Алгоритм Флойда-Уоршелла (Поиск кратчайших путей между всеми парами вершин.)
*Задача:* Дан взвешенный граф. Необходимо найти кратчайшие пути между
вершинами.

*Ключевые вопросы:*

Из одной вершины:
+ Найти кратчайшие пути от одной выделенной вершины до всех остальных.
+ Между всеми парами: Найти кратчайшие пути от каждой вершины до каждой.

- *Важно*: Алгоритм Флойда-Уоршелла работает с ориентированными и
  неориентированными графами. Допускает отрицательные веса, но не допускает
  циклов отрицательного веса.

== Алгоритм
*Вход:* Матрица смежности $W$ размером $n times n$, где:
- $W[i][j] = w(i, j)$ --- вес ребра $(i, j)$, если оно существует
- $W[i][j] = infinity$ --- если ребра нет
- $W[i][j] = 0$ --- расстояние от вершины до самой себя

*Выход:* Матрица $D$ размером $n times n$, где $D[i][j] = d(i, j)$ --- длина
кратчайшего пути из $i$ в $j$

== Псевдокод
```
for k in range(n):
    for i in range(n):
        for j in range(n):
            if dist[i][k] + dist[k][j] < dist[i][j]:
                dist[i][j] = dist[i][k] + dist[k][j]
```

Сложность: $O(|V|^3)$ (три вложенных цикла)
Память: $O(|V|^2)$

== Алгоритм Форда-Беллмана (взвешенные графы)

*Цель* Найти кратчайшие пути от выбранной вершины до всех остальных вершин графа.

*Особенность* Работает с ребрами, имеющие отрицатиельные и неотрицательные веса.

/ Алгоритм Форда-Беллмана: --- алгоритм поиска кратчайшего пути во взвешенном графе
  Допускает ребра с отрицательными весами

*Класс решаемых задач:* Дан орентиро // TODO:

```
// Заполнение начальными значениями
for v in V
  do d[v] <- + inf
d[s] <- 0

// |V| - 1 итерация
for i <- 1 to |V| - 1
  do for (u, v) in E
    if d[v] > d[u] + w(u, v)
      then d[v] <- d[u] + w(u, v)

// Проверка на отрицательный цикл
for (u, v) in E
  if d[v] > d[u] + w(u, v)
    then return False
return d
```

*Сложность алгоритма:* $O(|V| dot |E|)$

*Обоснование:* Алгоритм выполняет $|V| - 1$ итерацию основного цикла и 1 итерацию
для проверки отрицательного цикала. Внутри каждой итерации он просматривает все
$|E|$ ребер.

*Лучшее время:* $O(|E|)$
