== Поток, сеть, пропускная способность.

*Сетью G* = #sym.chevron.l V, E #sym.chevron.r называется ориентированный граф, такой, что 

$
forall (u, v) in E space c(u, v) > 0\
forall (u, v) in.not E space c(u, v) = 0
$
_Т.е. в таком графе каждое дуга имеет положительную пропускную способность, а если дуга графу не принадлежит, то его пропускная способность принимается за 0._

Функцию $c(u, v)$ называют *пропускной способностью* дуги $(u, v)$.

В транспортной сети выделяются две вершины: исток ($s$) и сток ($t$)

*Потоком в сети $G$* называется действительная функция $f : V crossmark V -> RR$, такая, что $forall u, v in V$:

+ $f(u, v) = - f(v, u)$ (свойство антисимметричности)
+ $f(u, v) <= c(u, v)$. _Величина потока на любой дуге всегда меньше или равна его пропускной способности_
+ $limits(sum)_v f(u, v) = 0$. _Сумма входящих потоков равна сумме исходящих для всех вершин за исключением истока и стока_.

*Величиной потока* называется сумма потоков из источника или сумма потоков в сток.

== Задача максимального потока
Ключевой в теории потоков является задача о максимальном потоке.

*Задача.* Пусть дана сеть $G = #sym.chevron.l V, E #sym.chevron.r$. Требуется найти функцию потока:
$ f_"max" = limits(max)_f abs(f) $
Такую функцию называют функцией максимального потока.

*Разрезом графа* называется пара непересекающихся множеств вершин $(A, B)$ такая, что $V = A union.big B, space s in A, t in B$.

*Величиной* разреза называется сумма пропускных способностей всех рёбер, ведущих из множества $A$ в множество $B$.

Разрез нужен для того, чтобы определить "бутылочное" горлышко сети. Минимальный разрез (разрез с минимальной пропускной способностью) показывает, через какое множество рёбер сеть пропускает наименьший возможный суммарный поток.

== Алгоритм Форда-фалкерсона
- *Увеличивающим путём* называют путь из $s$ в $t$ остаточной сети, по которому каждая дуга имеет положительную остаточную пропускную способность, т.е. по данному пути можно увеличить поток.
- *Остаточной сетью* называется вспомогательный граф, показывающий, какую величину потока можно пустить через его дуги. Для каждой дуги определяют остаточную пропускную способность: $c_f(u, v) = c(u, v) - f(u, v)$ _(разница между максимальной пропускной способностью и текущим потоком)_

=== Описание алгоритма
+ Все потоки выставляем в 0
+ В остаточной сети находим любой путь из источника в сток обходом в глубину. Если пути нет, то завершаем работу.
+ На найденном увеличивающем пути пускаем максимально возможный поток.
  + На найденном пути ищем реьро с минимальной пропускной способностью $c_min$.
  + Для каждого ребра на пути увеличиваем поток на $c_min$, а противоположный ему уменьшаем на эту величину.
  + Для всех рёбер на найденном пути, а также для противоположных им, вычисляем новую пропускную способность. Если она ненулевая, то добавляем ребро к остаточной сети, а если обнулилась, то стираем.
+ Возвращаемся на шаг 2.

=== Псевдокод
```
func FordFulkerson(G, s, t):
  для всех рёбер (u, v) в G:
    f(u, v) := 0
  
  пока существует увеличивающий путь P из s в t в остаточной сети G_f:
    delta := min(c_f(u, v), (u, v)) // бутылочное горлышко
    для (u, v) в P:
      f(u, v) := f(u, v) + delta // увеличиваем по прямому
      f(v, u) := f(v, u) - delta // уменьшаем по обратному

  вернуть сумму потоков, выходящих из s
```

Более эффективной реализацией алгоритма Форда-фалкерсона является алгоритм Эдмондса-Карпа, который вместо обхода вглубину для поиска пути, обходит граф вширину.